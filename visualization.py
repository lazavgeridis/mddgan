"""
Functions used in various visualization operations, demonstrating
the edits produced by the discovered semantics.
"""

import os
import torch
import numpy as np

from utils import (select_bases, semantic_edit, parse_indices,
                    key_to_title)
from PIL import Image
from tqdm import tqdm
from torchvision.utils import make_grid
from matplotlib import pyplot as plt


def postprocess(images, min_val=-1.0, max_val=1.0):
    """
    Post-process images from torch.Tensor to numpy.ndarray.

    Parameters
    ----------
    images : torch.Tensor
        A tensor (BxCxHxW) to process.
    min_val : float
        The minimum value of the input tensor (the default is -1.0).
    max_val : float
        The maximum value of the input tensor (the default is 1.0).

    Returns
    -------
    numpy.ndarray
                  A tensor with shape (B, C, H, W) and pixel range [0, 255].

    """
    assert isinstance(images, torch.Tensor)
    images = images.detach().cpu().numpy()
    images = (images - min_val) * 255 / (max_val - min_val)
    images = np.clip(images + 0.5, 0, 255).astype(np.uint8)
    images = images.transpose(1, 2, 0)

    return images


def draw_chart(fig):
    """
    Convert a matplotlib.figure.Figure to numpy.ndarray.

    Parameters
    ----------
    fig : matplotlib.figure.Figure
        Figure to convert to numpy array.

    Returns
    -------
    numpy.ndarray
                  The numpy array equivalent of the input figure.

    """
    fig.canvas.draw()
    chart = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
    chart = chart.reshape(fig.canvas.get_width_height()[::-1] + (3,))

    # crop borders
    nonzero_columns = np.count_nonzero(chart != 255, axis=0)[:, 0] > 0
    chart = chart.transpose(1, 0, 2)[nonzero_columns].transpose(1, 0, 2)

    return chart


def interpolation(G, layers, gan_type, proj_code, direction, magnitudes):
    """
    Create a sequence of N synthetic images.

    Each image in the sequence is generated by:
            I_j = G(z + ε_j*n),
    where I_j is a synthetic image (CxHxW), `G` is the generator function, z
    corresponds to `proj_code`, ε_j is the magnitude of the edit and n
    corresponds to `direction`. Index j \in [1, N].

    Parameters
    ----------
    G : torch.nn.module
        Generator network that synthesizes images.
    layers : list of int
        Subset of layers to apply the semantic's effect.
        Used only in the case of StyleGAN/StyleGAN2.
    gan_type : {'pggan', 'stylegan', 'stylegan2'}
        GAN model type.
    proj_code : torch.Tensor
        desc.
    direction : numpy.ndarray
        desc.
    magnitudes : numpy.ndarray

    Returns
    -------
    list of torch.Tensor
                         Sequence of edited synthetic images, where each image
                         I_j is generated using the equation above.

    """
    images_per_direction = []
    for m in magnitudes:
        temp_proj_code = torch.clone(proj_code).detach()
        image = semantic_edit(G, layers, gan_type, temp_proj_code, direction, m)
        images_per_direction.append(image.squeeze(0))

    return images_per_direction


def interpolation_chart(G,
                        layers,
                        gan_type,
                        basis,
                        proj_code,
                        magnitudes,
                        n_directions,
                        title=None,
                        begin=None,
                        end=None,
                        show_original=True,
                        **kwargs):
    """
    Create a figure with `n_directions` interpolation rows, showcasing how
    each direction alters the initial synthesized image.

    Parameters
    ----------
    G : torch.nn.module
        Generator network that synthesizes images.
    layers : list of int
        Subset of layers to apply the semantics' effect. Used only in the
        case of StyleGAN/StyleGAN2.
    gan_type : {'pggan', 'stylegan', 'stylegan2'}
        GAN model type.
    basis : numpy.ndarray
        Basis matrix of shape (|z|, |z|) in the general case. Each column
        of this matrix corresponds to a discovered direction.
    proj_code : torch.Tensor
        The result of the 1st generation step G_1(z)=y. Has shape (|z|).
    magnitudes : numpy.ndarray
        Array containing the values of the magnitudes to use when editing.
    n_directions : int
        Number of directions to use for visualization.
    title : str
        Figure title (the default is None).
    begin, end : int
        Direction indices to place on the left of each interpolation row
        (the default is None).
    show_original : bool
        Whether to show the original synthesized image in the top row or not
        (the default is True).
    **kwargs : dict
        Extra arguments passed to plt.subplots().

    Returns
    -------
    matplotlib.figure.Figure
                             A figure showcasing how the original synthesized
                             image is modified by editing it with the
                             discovered directions.

    """
    # prepare `n_directions` interpolation rows
    rows_per_page = []
    for i in range(n_directions):
        direction = basis[:, i]
        rows_per_page.append(interpolation(G, layers, gan_type, proj_code, direction, magnitudes))

    # create a figure to showcase the interpolation rows
    rows_num = n_directions + int(show_original)
    fig, ax = plt.subplots(nrows=rows_num, **kwargs) # **kwargs are passed to pyplot.figure()
    if title is not None:
        fig.suptitle(title)

    # show original image in 1st row
    if show_original:
        original_image = semantic_edit(G, layers, gan_type, proj_code, direction, 0).squeeze(0)
        ax[0].axis('off')
        ax[0].imshow(postprocess(original_image))

    # plot each linear interpolation sequence on the corresponing row
    if begin is not None and end is not None:
        desc = range(begin, end)
    else:
        desc = range(n_directions)
    for axis, direction_interp, text in zip(ax[int(show_original):], rows_per_page, desc):
        axis.axis('off')
        #plt.subplots_adjust(left=0.25)  # setting left=0.2 or lower eliminates whitespace between charts
        axis.imshow(postprocess(make_grid(direction_interp, nrow=magnitudes.shape[0])))
        axis.text(0, 0.5, str(text), horizontalalignment='right',
                  verticalalignment='center', fontsize='xx-small',
                  transform=axis.transAxes)

    return fig


def lerp_matrix(G,
                gan_type,
                layers,
                basis_list,
                proj_codes,
                n_samples,
                magnitudes,
                results_dir,
                max_columns=45,
                directions_per_page=15):
    """
    Create an interpolation chart demonstrating the effects of the first
    `max_columns` discovered directions. It can also compare MddGAN to SeFa.

    Parameters
    ----------
    G : torch.nn.module
        Generator network that synthesizes images.
    gan_type : {'pggan', 'stylegan', 'stylegan2'}
        GAN model type.
    layers : list of int
        Subset of layers to apply the semantic's effect. Used only in the
        case of StyleGAN/StyleGAN2.
    basis_list : list of numpy.ndarray
        Contains the basis matrix of shape (|z|, |z|) in the general case.
        Each column of this matrix corresponds to a discovered direction.
        When comparing MddGAN to SeFa, this list contains 2 such matrices.
    proj_codes : torch.Tensor
        The result of the 1st generation step G_1(z)=y. Has shape (B, |z|).
    n_samples : int
        Number of generated samples to use for visualization.
    magnitudes : numpy.ndarray
        Array containing the values of the magnitudes to use when editing.
    results_dir : str
        Path to directory where the results will be saved.
    max_columns : int
        Number of directions to visualize (the default is 45).
    directions_per_page : int
        Number of directions on each visualization page (the default is 15).

    Returns
    -------
    None

    """
    assert all(basis.ndim == 2 for basis in basis_list)
    max_columns = min(max_columns, basis_list[0].shape[1])

    if len(basis_list) == 2:
        method_names = ['MddGAN', 'SeFa']
        n_samples = 1
    else:
        method_names = [None]

    # visualize the effect of `directions_per_page` directions on each page
    pbar = tqdm(range(0, max_columns, directions_per_page))
    for begin in pbar:
        end = min(max_columns, begin + directions_per_page)
        pbar.set_description(desc=f'Creating chart for directions {begin}-{end}... ')
        charts = []

        # create an interpolation chart for each sample
        for sample_id in range(n_samples):
          code = proj_codes[sample_id:sample_id + 1]
          for idx, name in enumerate(method_names):
              basis_matrix = basis_list[idx]
              submatrix = basis_matrix[:, begin:end]

              # create figure
              fig = interpolation_chart(G, layers, gan_type, submatrix, code,
                                        magnitudes, end - begin, title=name,
                                        begin=begin, end=end, dpi=600,
                                        constrained_layout=True)

              # convert figure to numpy and append it to `charts` list
              charts.append(draw_chart(fig))

              # conserve memory
              fig.clf()
              plt.close(fig)

        # concatenate charts (horizontally) into a single grid, save the grid
        out_file = os.path.join(results_dir, f'directions_{begin}_{end}.jpg')
        print('Saving chart to ', out_file)
        Image.fromarray(np.hstack(charts)).save(out_file) # concatenate figures column-wise


def lerp_tensor(G,
                gan_type,
                layers,
                basis,
                basis_dims,
                proj_codes,
                n_samples,
                magnitudes,
                results_dir,
                directions_per_page=15,
                n_secondary_bases=3):
    """
    Investigate how the discovered directions are separated into the dimensions
    of the multilinear basis \mathcal{B}.

    Parameters
    ----------
    G : torch.nn.module
        Generator network that synthesizes images.
    gan_type : {'pggan', 'stylegan', 'stylegan2'}
        GAN model type.
    layers : list of int
        Subset of layers to apply the semantics' effect. Used only in the
        case of StyleGAN/StyleGAN2.
    basis : numpy.ndarray
        Basis matrix of shape (|z|, |z|) in the general case. Each column
        of the matrix is a discovered direction.
    basis_dims : list of int
        The dimensions K_2, K_3, ..., K_M of the multilinear basis.
    proj_codes : torch.Tensor
        The result of the 1st generation step G_1(z)=y. Has shape (B, |z|).
    n_samples : int
        Number of generated samples to use for visualization.
    magnitudes : numpy.ndarray
        Array containing the values of the magnitudes to use when editing.
    results_dir : str
        Path to directory where the results will be saved.
    directions_per_page : int
        Number of directions on each visualization page (the default is 15).
    n_secondary_bases : int
        How many bases of the secondary tensor mode to explore.

    Returns
    -------
    None

    """
    # tensorize `basis`, in case it is in matrix form
    if basis.ndim == 2:
        basis = basis.reshape(basis.shape[0], *basis_dims)

    assert (basis.ndim > 2 and basis.ndim < 6), ('More than 4 modes of '
            'variation are not supported yet.')

    # investigate each mode of the `basis` tensor
    # tensor has shape (d, K_2, K_3, ..., K_M)
    pbar = tqdm(enumerate(basis_dims))
    for primary_mode_idx, primary_mode_dim in pbar:
        pbar.set_description(desc='Creating chart for tensor mode'
                                f' {primary_mode_idx + 2}... ')
        mode_dir = os.path.join(results_dir, f'Mode_{primary_mode_idx + 1}')
        os.makedirs(mode_dir, exist_ok=True)
        for secondary_mode_idx, secondary_mode_dim in enumerate(basis_dims):
            if primary_mode_idx == secondary_mode_idx:
                continue
            for base_idx in range(min(n_secondary_bases, secondary_mode_dim)):

        #for secondary_base_idx in range(n_secondary_bases):
                charts = []
                for sample_id in range(n_samples):
                    code = proj_codes[sample_id:sample_id + 1]
                    #bases, subscript = select_bases(basis, primary_mode_idx, secondary_base_idx, len(basis_dims))
                    bases, subscript = select_bases(basis, primary_mode_idx, secondary_mode_idx, base_idx, len(basis_dims))
                    directions_num = min(directions_per_page, bases.shape[1])

                    # create figure 
                    fig = interpolation_chart(G, layers, gan_type, bases, code,
                                            magnitudes, directions_num, dpi=600,
                                            constrained_layout=True)

                    # draw chart and append it to `charts` list
                    charts.append(draw_chart(fig))

                    # conserve memory
                    fig.clf()
                    plt.close(fig)

                # concatenate charts (horizontally) into a single grid, save the grid
                out_file = os.path.join(mode_dir, f'B[{subscript}].jpg')
                print('Saving chart to ', out_file)
                Image.fromarray(np.hstack(charts)).save(out_file) # concatenate figures column-wise


def create_comparison_chart(G,
                            gan_type,
                            trunc_psi,
                            trunc_layers,
                            layers,
                            semantics,
                            magnitudes,
                            text,
                            reverse=False,
                            n_samples=2):
    """ 
    Compare 2 semantics discovered by different methods (e.g MddGAN and SeFa),
    but achieving the same effect.

    Create and visualize a comparison chart demonstrating both produced effects
    on the same generated sample, via linear interpolation. Top row corresponds
    to the effect produced by the competing method (InterFaceGAN or SeFa), while
    the bottom row corresponds to the effect produced by MddGAN.

    Parameters
    ----------
    G : torch.nn.module
        Generator network that synthesizes images.
    gan_type : {'pggan', 'stylegan', 'stylegan2'}
        GAN model type.
    trunc_psi : float
        A StyleGAN/StyleGAN2 specific value used to "cutoff" some regions
        of the generator distribution p_g, aka the "truncation trick" (the
        default is 0.7).
    trunc_layers : int
        A StyleGAN/StyleGAN2 specific value indicating the number of layers
        to apply the "truncation trick" (the default is 8).
    layers : list of int
        Subset of layers to apply the semantics' effect. Used only in the
        case of StyleGAN/StyleGAN2.
    semantics : list of torch.Tensor
        Semantics used to edit. Index [0] corresponds to the semantic
        discovered by the competing method, index [1] to the semantic
        discovered by MddGAN.
    magnitudes : numpy.ndarray
        Array containing the values of the magnitudes to use when editing.
    text : list of str
        Names of the methods to compare. They are placed on the left of
        each interpolation row. Index [1] always corresponds to MddGAN.
    reverse : bool
        Used for certain semantics, in order to evenly compare the results
        (the default is False).
    n_samples : int
        Number of generated samples to use for the comparison (the default
        is 2).

    Returns
    -------
    None

    """
    fig, ax = plt.subplots(nrows=2*n_samples, dpi=600, constrained_layout=True)

    latent_vectors = torch.randn(n_samples, G.z_space_dim, device='cuda')
    if gan_type == 'pggan':
        codes = G.layer0.pixel_norm(latent_vectors)
    elif gan_type == 'stylegan' or gan_type == 'stylegan2':
        codes = G.mapping(latent_vectors)['w']
        codes = G.truncation(codes, trunc_psi=trunc_psi, trunc_layers=trunc_layers)

    for i in range(n_samples):
        for method_idx in range(2):
            ax_idx = i * n_samples + method_idx
            ax[ax_idx].axis('off')
            ax[ax_idx].imshow(
                    postprocess(
                        make_grid(
                            interpolation(G,
                                        layers[method_idx],
                                        gan_type,
                                        codes[i:i+1],
                                        semantics[method_idx],
                                        magnitudes[::-1] if method_idx == 1 and reverse else magnitudes),
                                        nrow=magnitudes.shape[0])
                        )
                    )
            ax[ax_idx].text(0, 0.5,
                            text[method_idx],
                            horizontalalignment='right',
                            verticalalignment='center',
                            rotation='vertical',
                            fontsize='medium',
                            fontweight='bold' if text[method_idx] == 'Ours' else 'regular',
                            transform=ax[ax_idx].transAxes)

    # draw horizontal line
    if n_samples > 1:
        line = plt.Line2D([0.1, 0.9], [0.5, 0.5], color="k", linewidth=1)
        fig.add_artist(line)

    plt.show()


def fid_plot(title, x_axis, competing_fid, mddgan_fid, competing_name):
    """
    Plot FID scores of the 2 methods for the same discovered direction.

    Parameters
    ----------
    title : str
        Title of the plot.
    x_axis : list of float
        Common magnitude values used during FID calculation.
    competing_fid : list of float
        Resulting FID scores for the direction discovered by the
        competing method.
    mddgan_fid : list of float
        Resulting FID scores for the direction discovered by MddGAN.
    competing_name : str
        Name of the competing method (InterFaceGAN or SeFa).

    Returns
    -------
    None

    """
    fig, ax = plt.subplots()
    fig.suptitle(title)
    ax.set_xlabel('Magnitude')
    ax.set_ylabel('FID')
    ax.plot(x_axis, competing_fid, 'o-', label=competing_name)
    ax.plot(x_axis, mddgan_fid, 'o-', label='mddgan')
    ax.legend()
    fig.savefig('fid.png')


def create_attribute_chart(proj_codes,
                           layers,
                           generator,
                           magnitude,
                           gan_type,
                           semantic,
                           attr_name):

    interpolations = []
    for code_idx in range(proj_codes.shape[0]):
        interpolations.append(interpolation(generator, layers, gan_type,
            proj_codes[code_idx:code_idx+1], semantic, [magnitude]))

    assert len(interpolations) == (proj_codes.shape[0])

    fig, axs = plt.subplots(nrows=proj_codes.shape[0], dpi=600, constrained_layout=True)
    fig.suptitle(key_to_title(attr_name))

    for ax, interp in zip(axs, interpolations):
      ax.axis('off')
      ax.imshow(postprocess(interp[0]))

    return fig


def create_semantic_chart(G,
                          gan_type,
                          proj_codes,
                          attr_dict,
                          args,
                          n_samples_per_page=4):

    total_samples = proj_codes.size()[0]
    n_pages = int(total_samples / n_samples_per_page)

    for i in range(n_pages):
        start = i * n_samples_per_page
        end = min(start + n_samples_per_page, total_samples)
        codes = proj_codes[start:end]

        charts = []
        for idx, (key, item) in enumerate(attr_dict.items()):

            print(f'Creating {key} chart...')

            if idx == 0:
                fig = create_attribute_chart(codes,
                                             list(range(G.num_layers)),
                                             G,
                                             0.0,
                                             gan_type,
                                             torch.zeros(G.z_space_dim),
                                             key)

            else:
                # load the corresponding semantic 
                semantic = np.load(f'{args.semantic_dir}/{args.method_name}/{args.model_name}_{key}.npy')
                semantic = torch.from_numpy(semantic)

                #
                if args.method_name == 'interfacegan':
                    layers = list(range(G.num_layers))
                else:
                    layer_idx = item[0]
                    layers = parse_indices(layer_idx, min_val=0, max_val=G.num_layers - 1)
                magnitude = item[1]

                # create attribute chart
                fig = create_attribute_chart(codes,
                                             layers,
                                             G,
                                             magnitude,
                                             gan_type,
                                             semantic,
                                             key)

            # draw vertical dotted line
            if idx != len(attr_dict) - 1:
                line = plt.Line2D([1.0, 1.0], [0, 1], color="k", linewidth=5, transform=fig.transFigure)
                fig.add_artist(line)

            # draw chart figure
            charts.append(draw_chart(fig))

            # conserve memory
            fig.clf()
            plt.close(fig)

        # save chart
        out_file = os.path.join(args.save_dir, f'{args.method_name}_{args.model_name}_{start}_{end}.jpg')
        print(f'Saving chart to {out_file}\n')
        Image.fromarray(np.hstack(charts)).save(out_file) # concatenate figures column-wis
